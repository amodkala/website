import { Outlet, Link } from "react-router-dom";
import Collapsible from "../../components/Collapsible";

## Leetcode

***Wednesday, September 4, 2024***

Doing some last-minute prep for the Google OA that everyone seems to have 
received this week.

Topics
- Array techniques (sliding window, two pointer)
- String problems (palindrome, substring/subsequence, bitwise operations)
- 1-D dynamic programming
- Tree problems (distance, traversal)
- Graph problems (shortest path, number of paths)

<Link to="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</Link>  
One-shotted this solution, basic sliding window technique with a hash table to
track the last known index of a character

<Collapsible>

```python
def lengthOfLongestSubstring(self, s: str) -> int:
    ref = {}
    start, end, ans = 0, 0, 0
    for i, char in enumerate(s):
        if char in ref and ref[char] >= start:
            start = ref[char] + 1
        if char not in ref or ref[char] < start:
            ans = max(ans, end - start + 1)
            end = end + 1
        ref[char] = i
    return ans
```
</Collapsible>

<Link to="https://leetcode.com/problems/house-robber/">House Robber</Link>  
Took a bit longer to grok the DP method of breaking algorithms into recursive
subproblems and storing intermediate results to save on computation.

<Collapsible>

```python
def rob(self, nums: List[int]) -> int:
    if len(nums) == 1:
        return nums[0]
    i, ans = 2, 0
    ref = [nums[0], max(nums[0], nums[1])]
    while i < len(nums):
        ref.append(max(nums[i] + ref[i-2], ref[i-1]))
        i = i + 1      
    return ref[len(nums)-1]
```
</Collapsible>

<Link to="">Container with Most Water</Link>  
Another simple two-pointer greedy algorithm, O(n) solution

<Collapsible>

```python
def maxArea(self, height: List[int]) -> int:
    l, r = 0, len(height)-1
    ans = 0
    while l != r:
        ans = max(min(height[l], height[r]) * (r - l), ans)
        if height[l] < height[r]:
            l = l + 1
        else:
            r = r - 1
    return ans
```
</Collapsible>

<Link
  to="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary
  Tree Level Order Traversal</Link>  
Classic BFS solution using tuples to store metadata

<Collapsible>

```python
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
    if root is None:
        return []
    ref = []
    queue = [(root, 0)]
    while queue:
        (node, level) = queue.pop(0)
        if node is None:
            continue
        if len(ref) < level + 1:
            ref.append([])
        ref[level].append(node.val)
        queue.append((node.left, level+1))
        queue.append((node.right, level+1))
    return ref
```
</Collapsible>

<Link to="https://leetcode.com/problems/number-of-islands/">Number of
  Islands</Link>  
Another BFS problem, I want to be comfortable implementing graph traversal
algorithms independent of any problem-specific logic

<Collapsible>

```python
def numIslands(self, grid: List[List[str]]) -> int:
    def bfs(r, c):
        moves = [(-1,0),(1,0),(0,-1),(0,1)]
        queue = [(r,c)]
        visited = set()
        visited.add((r,c))
        while queue:
            (r, c) = queue.pop(0)
            grid[r][c] = "0"
            for (x, y) in moves:
                valid = (r+y >= 0 and r+y < len(grid)) and (c+x >= 0 and c+x < len(grid[0]))
                if valid and grid[r+y][c+x] == "1" and (r+y,c+x) not in visited:
                    queue.append((r+y,c+x))
                    visited.add((r+y,c+x))

    ans = 0
    for row in range(len(grid)):
        for column in range(len(grid[0])):
            if grid[row][column] == "1":
                ans = ans + 1
                bfs(row, column)
    return ans
```
</Collapsible>

<Link to="https://leetcode.com/problems/flood-fill/">Flood Fill</Link>  
This is the easiest BFS problem that I'm aware exists on the Leetcode platform.
Good for practicing muscle memory

<Collapsible>

```python
def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
    start = image[sr][sc]
    if color == start:
        return image
    moves = [(-1,0),(1,0),(0,-1),(0,1)]
    visited = set()
    queue = [(sr, sc)]
    visited.add((sr,sc))
    while queue:
        (r,c) = queue.pop(0)
        image[r][c] = color
        for (x,y) in moves:
            valid = (r+y >= 0 and r+y < len(image)) and (c+x >= 0 and c+x < len(image[0]))
            if valid and image[r+y][c+x] == start and (r+y,c+x) not in visited:
                queue.append((r+y,c+x))
                visited.add((r+y,c+x))
    return image
```
</Collapsible>

<Link
  to="https://leetcode.com/problems/longest-increasing-subsequence/">Longest
  Increasing Subsequence</Link>  
One of the classic DP problems, I ultimately needed some help with deriving the
O(n^2) solution below, though I am aware that an O(nlogn) solution exists

<Collapsible>

```python
def lengthOfLIS(self, nums: List[int]) -> int:
    ref = [1]
    i = 1
    while i < len(nums):
        j, val = 0, 0
        while j < i:
            if nums[j] < nums[i]:
                val = max(val, ref[j])
            j = j + 1
        ref.append(1 + val)
        i = i + 1
        
    ans = 0
    for LIS in ref:
        ans = max(ans, LIS)
    return ans
```
</Collapsible>

<Link to="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</Link>  
I had to go back and review this problem because the intuition escaped me. For
posterity, ref[i-1] is the number of ways to reach step i with one step and 
likewise for ref[i-2] and two steps. Their sum is thus the number of ways to
reach step i with either one or two steps (per the problem description) and so
we simply need to calculate ref[n] (minus one to account for the step/index
mismatch)

<Collapsible>

```python
def climbStairs(self, n: int) -> int:
    ref = [1,2]
    for i in range(2,n):
        ref.append(ref[i-1] + ref[i-2])
    return ref[n-1]
```
</Collapsible>

<Link to="https://leetcode.com/problems/min-cost-climbing-stairs/">Min Cost
Climbing Stairs</Link>  
This variation on the previous problem was way more intuitive to me  

<Collapsible>

```python
def minCostClimbingStairs(self, cost: List[int]) -> int:
    ans, i = 0, 2
    ref = cost[:2]
    while i < len(cost):
        ref.append(cost[i] + min(ref[i-1], ref[i-2]))
        i += 1
    return min(ref[i-1], ref[i-2])
```
</Collapsible>

<Link to="https://leetcode.com/problems/merge-k-sorted-lists/">Merge K Sorted
Lists</Link>    
This was the first hard problem I completed, on my first attempt too! In all
fairness I was already familiar with the design of merge iterators thanks to
Alex Petrov's <Link to="https://www.databass.dev/">Database Internals</Link>,
but the requirement that I return the merged list as a linked list was a welcome
opportunity to refresh my knowledge of how to work with that data structure

<Collapsible>

```python
def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    heap = []
    head = ListNode()
    prev = head
    ref = {}
    for node in lists:
        if node is not None:
            if node.val not in ref:
                ref[node.val] = 0
            heappush(heap, (node.val, ref[node.val], node.next))
            ref[node.val] += 1
    
    while heap:
        (value, _, nextNode) = heappop(heap)
        newNode = ListNode()
        newNode.val = value
        newNode.next = None
        prev.next = newNode
        prev = prev.next
        if nextNode is not None:
            if nextNode.val not in ref:
                ref[nextNode.val] = 0
            heappush(heap, (nextNode.val, ref[nextNode.val], nextNode.next))
            ref[nextNode.val] += 1
    return head.next
```
</Collapsible>

<Link to="https://leetcode.com/problems/group-anagrams/">Group Anagrams</Link>  
I previously solved this problem by sorting each string, but mapping characters
to prime numbers is O(n) instead of O(nlogn)

<Collapsible>

```python
def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
    primes = [
        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 
        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101
    ]
    ref = {}
    for s in strs:
        val = 1
        for c in s:
            val *= primes[ord(c) - ord('a')]
        if val not in ref:
            ref[val] = []
        ref[val].append(s)
    return [words for (k, words) in ref.items()]
```
</Collapsible>

<Link to="https://leetcode.com/problems/longest-consecutive-sequence/">Longest
Consecutive Sequence</Link>  
I tried to be clever here and store previously computed values in a hash table,
which I discovered was necessary to avoid a TLE without modifying the algorithm,
however the space overhead is quite high (worse than ~95% of other submissions)
so I doubt it would be acceptable in an interview

<Collapsible>

```python
def longestConsecutive(self, nums: List[int]) -> int:
    ref = {}
    s = set(nums)
    ans = 0
    for num in s:
        length = 1
        prev = num - 1
        while prev in s:
            if prev in ref:
                length += ref[prev]
                break
            length += 1
            prev -= 1
        ref[num] = length
        ans = max(ans, length)
    return ans
```
</Collapsible>

<Link to="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best
Time to Buy and Sell Stock</Link>  
Revisited this classic since I read that Google tends to ask array/string
questions in their online assessment and I didn't want to get caught off guard.
I actually haven't done this one in forever so I got to rederive the solution

<Collapsible>

```python
def maxProfit(self, prices: List[int]) -> int:
    lowest, ans = prices[0], 0
    for price in prices:
        lowest = min(lowest, price)
        ans = max(ans, price - lowest)
    return ans
```
</Collapsible>

***Thursday, September 12, 2024***

Some notes on Google's snapshot coding assignment, which I wrote yesterday:
- The assignment asks candidates to solve two coding problems in 90 minutes,
  providing your own test cases to run your code against
- I'd say that the problems themselves were at the level of a Leetcode Easy
  (scratch that, apparently one of the questions is on Leetcode as a "hard"
  problem), though one question explicitly asked for an efficient solution while
  the other placed more emphasis on correctness
- I managed to provide optimal solutions for both problems, tests for all the 
  edge cases I could think of, and time + space complexity analysis.

My advice for applicants writing this OA in the future is this:
- Simulate the testing environment as closely as possible during your prep. I
  think I spent more than half of the time either not writing code or making
  simple mistakes because of how nervous I was. This includes context switching
  between two problems, budgeting time, and using a timer.
- Use your own editor. Seriously. The provided editor has auto-indentation (2 
  spaces) and syntax highlighting, that's it. If you're used to writing code
  with line numbers, vim keybinds, or even dark mode you'd be shocked at how
  much of a debuff it is to go without those features. 

***Sunday, September 15, 2024***

More Leetcode prep.

<Link
to="https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/">Nearest
Exit From Entrance in Maze</Link>  
Another simple BFS problem with some slight optimisations. As soon as a solution
is found you can return it instead of ensuring it is the minimum such value,
since the nature of BFS implies that the first solution found is the nearest.
The other optimisation is to simply update maze spaces to be inaccessible
instead of maintaining a set of visited spaces. In my initial solution below I
implemented the first optimisation but not the second.

<Collapsible>

```python
def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
    moves = [(-1,0),(1,0),(0,-1),(0,1)]
    visited = set()
    queue = [(entrance[0], entrance[1], 0)]
    visited.add((entrance[0], entrance[1]))
    while queue:
        (r, c, steps) = queue.pop(0)
        if [r,c] != entrance and ((r == 0 or r == len(maze) - 1) or (c == 0 or c == len(maze[0]) - 1)):
            return steps
        for (x, y) in moves:
            valid = (r+y >= 0 and r+y < len(maze)) and (c+x >= 0 and c+x < len(maze[0]))
            if valid and (r+y, c+x) not in visited and maze[r+y][c+x] == ".":
                queue.append((r+y,c+x,steps+1))
                visited.add((r+y,c+x))
    return -1
```
</Collapsible>

<Link to="https://leetcode.com/problems/longest-common-subsequence/">Longest
Common Subsequence</Link>  
I had to reference a few solutions before solving the problem myself, which I
consider a failure, but hopefully I will be able to recognize the pattern for
future problems.

<Collapsible>

```python
def longestCommonSubsequence(self, text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
```
</Collapsible>

<Link to="https://leetcode.com/problems/binary-tree-maximum-path-sum/">Binary
Tree Maximum Path Sum</Link>  
Quick and dirty recursive solution. Much like DP problems, breaking the problem
down into the smallest recursive subproblem possible is an effective strategy. 
Here, that subproblem boiled down to "for each node, what is the max path sum 
with root at or below this node, and what is the maximum contribution to a 
solution with root above this node".

<Collapsible>

```python
def maxPathSum(self, root: Optional[TreeNode]) -> int:
    def helper(root) -> (int, int):
        if root is None:
            return (-1000, -1000)

        (left_highest, left_path) = helper(root.left)
        (right_highest, right_path) = helper(root.right)

        curr_path = root.val + max(0, left_path, right_path)
        curr_highest = max(curr_path, root.val + left_path + right_path, left_highest, right_highest)

        return (curr_highest, curr_path)

    (highest, _) = helper(root)
    return highest
```
</Collapsible>

<Link to="https://leetcode.com/problems/validate-binary-search-tree/">Validate
Binary Search Tree</Link>  
Easy recursive solution. I probably did this in Racket for a CS 135 assignment
back in the day.

<Collapsible>

```python
def isValidBST(self, root: Optional[TreeNode]) -> bool:
    def helper(root, highest, lowest) -> bool:
        if root is None:
            return True
        return (
            root.val < highest and 
            root.val > lowest and 
            helper(root.left, root.val, lowest) and 
            helper(root.right, highest, root.val)
        )

    return helper(root, (2 ** 31) + 1, (-2 ** 31) - 1)
```
</Collapsible>

<Link
to="https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/">Minimum 
Number of Increments on Subarrays to Form a Target Array</Link>  
I'd solved this question before, but even still I hardly think it qualifies as a
"hard" problem. The intuition behind the O(n) solution is that when the target
at the current position is less than or equal to the target at the previous
position, the current position's target could be reached using the same moves as
the previous position, so no need to add to the count. When the current
position's target is greater than the previous position, we need target[i] -
target[i-1] additional moves, so we add that to the total.

<Collapsible>

```python
def minNumberOperations(self, target: List[int]) -> int:
    ans = target[0]
    for i in range(1, len(target)):
        if target[i] > target[i-1]:
            ans += target[i] - target[i-1]
    return ans
```
</Collapsible>

<Link to="https://leetcode.com/problems/unique-paths/">Unique Paths</Link>  
I used a 2-D DP table to develop my bottom-up solution. This is similar to the
Climbing Steps problem in that since we can only move down or right, the number
of unique paths to a position is the number of unique paths to get above that
position plus the number of unique paths to get to the left of the position.

<Collapsible>

```python
def uniquePaths(self, m: int, n: int) -> int:
    ref = [[1] * n for _ in range(m)]
    for r in range(1, m):
        for c in range(1, n):
            ref[r][c] = ref[r-1][c] + ref[r][c-1]
    return ref[m-1][n-1]
```
</Collapsible>
